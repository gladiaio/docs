---
title: "Quick migration guide: realtime STT from Deepgram to Gladia"
description: "Guide to seamlessly switch your realtime WebSocket transcription from Deepgram's SDK to Gladia's SDK."
sidebarTitle: "From Deepgram"
---

This step-by-step guide shows how to switch your realtime transcription from Deepgram to Gladia with minimal code changes. It highlights equivalences, subtle differences, and drop‑in replacements so you can migrate quickly and confidently, without any regressions.

## Step-by-step guide

### Install the SDK

Install the official SDKs to enable realtime streaming. That's all you need to get started in Python or TypeScript.

_For Deepgram :_

<CodeGroup>

```bash Python
pip install deepgram-sdk
```

```bash Typescript
npm i @deepgram/sdk
```

</CodeGroup>

_For Gladia:_

<CodeGroup>

```bash Python
pip install gladiaio-sdk
```

```bash Typescript
npm i @gladiaio/sdk
```

</CodeGroup>

### Initialize the client

Create and authenticate the client that manages your live connection. The shape is the same idea across providers—just swap the client and key.

_For Deepgram :_

<CodeGroup>

```python Python
from deepgram import DeepgramClient

deepgram_client = DeepgramClient(api_key="<YOUR_DEEPGRAM_API_KEY>")
```

```typescript Typescript
import { createClient } from "@deepgram/sdk";

const deepgramClient = createClient(process.env.DEEPGRAM_API_KEY);
```

</CodeGroup>

_For Gladia :_

<CodeGroup>

```python Python
from gladiaio_sdk import GladiaClient

gladia_client = GladiaClient(api_key="<YOUR_GLADIA_API_KEY>")
```

```typescript Typescript
import { GladiaClient } from "@gladiaio/sdk";

const gladiaClient = new GladiaClient({
  apiKey: process.env.GLADIA_API_KEY,
});
```

</CodeGroup>

### Configure the session

Choose the model, audio format, and language options your app needs. Most parameters map one‑to‑one, so your existing settings carry over naturally.

#### Deepgram to Gladia parameter mapping

|     Deepgram      |                        Gladia                         | Notes / Example                                                                                                       |
| :---------------: | :---------------------------------------------------: | --------------------------------------------------------------------------------------------------------------------- |
|      `model`      |                        `model`                        | Choose the latest Gladia model ("solaria-1").                                                                         |
|    `encoding`     |                      `encoding`                       | Match the actual [audio format](/api-reference/v2/live/init#body-encoding) (e.g., `linear16` ↔ `wav/pcm`).            |
|                   |                      `bit_depth`                      | Choose the [bit depth](/api-reference/v2/live/init#body-bit-depth) value from your audio                              |
|   `sample_rate`   |                     `sample_rate`                     | Same unit (Hz).                                                                                                       |
|    `channels`     |                      `channels`                       | Same meaning.                                                                                                         |
| `interim_results` |     `messages_config.receive_partial_transcripts`     | Set `true` to receive [partials messages](/chapters/live-stt/features/partial-transcripts).                           |
|   `endpointing`   | `endpointing`; `maximum_duration_without_endpointing` | Port thresholds and consider a hard cap.                                                                              |
|    `language`     |   `language_config.languages` (+ `code_switching`)    | Pass one or more languages; enable switching when [multiple languages](/chapters/language/code-switching) are spoken. |

```json Gladia config example
{
  "model": "solaria-1",
  "encoding": "wav/pcm",
  "bit_depth": 16,
  "sample_rate": 16000,
  "channels": 1,
  "language_config": { "languages": ["en"], "code_switching": false },
  "messages_config": {
    "receive_partial_transcripts": true,
    "receive_final_transcripts": true
  },
  "endpointing": 0.8,
  "maximum_duration_without_endpointing": 30,
  "realtime_processing": {
    "custom_vocabulary": false,
    "custom_spelling": false
  }
}
```

See the full schema in the [live init reference](/api-reference/v2/live/init).

### Start the transcription session

Open a live transcription session using your configuration. The flow is the same as with Deepgram: establish the WebSocket and get ready to stream audio.

_For Deepgram :_

<CodeGroup>

```python Python
with deepgram_client.listen.v1.connect(deepgram_config) as deepgram_connection:
    # Further code to add event handlers
    deepgram_connection.start_listening()
```

```typescript Typescript
const deepgramConnection = deepgramClient.listen.live(deepgramConfig);
```

</CodeGroup>

_For Gladia :_

<CodeGroup>

```python Python
gladia_session = gladia_client.live_v2().start_session(gladia_config)
```

```typescript Typescript
const gladiaSession = gladiaClient.liveV2().startSession(gladiaConfig);
```

</CodeGroup>

### Send audio chunks

Stream audio frames to the session as they are produced. Both SDKs accept small chunks continuously—keep your existing chunking logic.

_For Deepgram :_

<CodeGroup>

```python Python
deepgram_connection.send(audio_chunk)
```

```typescript Typescript
deepgramConnection.send(audioChunk);
```

</CodeGroup>

_For Gladia :_

<CodeGroup>

```python Python
gladia_session.send_audio(audio_chunk)
```

```typescript Typescript
gladiaSession.sendAudio(audioChunk);
```

</CodeGroup>

### Read transcription messages

After audio is flowing, subscribe to transcript and lifecycle events. The mapping below shows how to translate Deepgram listeners to Gladia in a single place.

Event mapping from Deepgram to Gladia:

- `Transcript` → listen to Gladia `message` and branch on `message.data.is_final` to separate partial vs final results.
- `Open`/`Close`/`Error` → map to Gladia `started`/`ended`/`error`.

In practice, subscribe once to `message` and use the `is_final` flag instead of wiring separate listeners—less boilerplate, same control. To receive partials, enable `messages_config.receive_partial_transcripts: true` in your init config.

_For Deepgram :_

<CodeGroup>

```python Python
from deepgram.core.events import EventType

def on_open(_):
    print("Deepgram connection opened")

def on_message(data, **kwargs):
    # Print the top alternative transcript if present
    print(data["channel"]["alternatives"][0])

def on_close(data, **kwargs):
    print("Deepgram connection closed")

def on_error(error, **kwargs):
    print("Error:", error)

deepgram_connection.on(EventType.OPEN, on_open)
deepgram_connection.on(EventType.MESSAGE, on_message)
deepgram_connection.on(EventType.CLOSE, on_close)
deepgram_connection.on(EventType.ERROR, on_error)
```

```typescript Typescript
deepgramConnection.on(LiveTranscriptionEvents.Open, () => {
  deepgramConnection.on(LiveTranscriptionEvents.Transcript, (data) => {
    console.log(data.channel.alternatives[0].transcript);
  });

  deepgramConnection.on(LiveTranscriptionEvents.Error, (err) => {
    console.error(err);
  });
});
```

</CodeGroup>

_For Gladia :_

<CodeGroup>

```python Python
from gladiaio_sdk import (
    LiveV2WebSocketMessage,
    LiveV2InitResponse,
    LiveV2EndedMessage,
)

@live_session.on("message")
def on_message(message: LiveV2WebSocketMessage):
    # Partial and final transcripts are delivered here
    # filter them with message.data.is_final field
    print(message)

@live_session.once("started")
def on_started(_response: LiveV2InitResponse):
    print("Session started. Listening...")

@live_session.once("ended")
def on_ended(_ended: LiveV2EndedMessage):
    print("Session ended.")

@live_session.on("error")
def on_error(error: Exception):
    print(f"Error: {error}")
```

```typescript Typescript
gladiaSession.on("message", (message) => {
  // Partial and final transcripts are delivered here
  // filter them with message.data.is_final field
  console.log(message);
});

gladiaSession.on("started", (info) => {
  console.log("Start session", info);
});

gladiaSession.on("ended", (info) => {
  console.log("End session", info);
});

gladiaSession.on("error", (err) => {
  console.error("Error", err);
});
```

</CodeGroup>
