import Samples from '/snippets/samples.mdx';
import PartialsTip from '/snippets/partials-tip.mdx';
import WhyPostToOpenWebSocket from '/snippets/why-post-to-open-websocket.mdx';

The SDK simplifies real-time speech-to-text integration by abstracting the underlying API. Designed for developers, it offers:
- Effortless implementation with minimal code to write.
- Built-in resilience with automatic error handling (e.g., reconnection on network drops) ensures uninterrupted transcription. No need to manually manage retries or state recovery.

## Install the SDK

<CodeGroup>

```sh JavaScript
npm install @gladiaio/sdk
```

```sh Python
# Using pip
pip install gladiaio-sdk

# Using uv
uv add gladiaio-sdk
```

</CodeGroup>

<CodeGroup>

```javascript JavaScript
import { GladiaClient } from "@gladiaio/sdk";
```

```python Python
from gladiaio_sdk import (
    GladiaClient,
    LiveV2InitRequest,
    LiveV2LanguageConfig,
    LiveV2MessagesConfig,
    LiveV2WebSocketMessage,
    LiveV2InitResponse,
    LiveV2EndedMessage,
)
```

</CodeGroup>

## Initiate your real-time session

First, call the [ endpoint](/api-reference/v2/live/init) and pass your configuration.
It's important to correctly define the properties `encoding`, `sample_rate`, `bit_depth` and `channels` as we need them to parse your audio chunks.

<CodeGroup>

```typescript JavaScript
const gladiaClient = new GladiaClient({
  apiKey: <YOUR_GLADIA_API_KEY>,
});

const gladiaConfig = {
  model: "solaria-1",
  encoding: 'wav/pcm',
  sample_rate: 16000,
  bit_depth: 16,
  channels: 1,
  language_config: {
    languages: ["fr"],
    code_switching: false,
  },
};

const liveSession = gladiaClient.liveV2().startSession(gladiaConfig);
```

```python Python
# Our Python SDK supports sync/threaded and asyncio versions.
gladia_client = GladiaClient(api_key="<YOUR_GLADIA_API_KEY>")

# sync/threaded version
live_client = gladia_client.live_v2()
# asyncio version
live_client = gladia_client.live_v2_async()

init_request = LiveV2InitRequest(
    model="solaria-1",
    encoding="wav/pcm",
    sample_rate=16000,
    bit_depth=16,
    channels=1,
    language_config=LiveV2LanguageConfig(languages=["fr"], code_switching=False),
    messages_config=LiveV2MessagesConfig(receive_partial_transcripts=True),
)

live_session = live_client.start_session(init_request)
```

</CodeGroup>


<WhyPostToOpenWebSocket />

## Connect to the WebSocket

Now that you've initiated the session and have the URL, you can connect to the WebSocket using your preferred language/framework. Here's an example in JavaScript:

<CodeGroup>

```typescript JavaScript
liveSession.on("message", (message) => {
  // Handle messages from the API
});
liveSession.on("started", (message) => {
  // Handle start session message
});
liveSession.on("ended", (message) => {
  // Handle end session message
});
liveSession.on("error", (message) => {
  // Handle error message
});
```

```python Python
from gladiaio_sdk import (
    LiveV2WebSocketMessage,
    LiveV2InitResponse,
    LiveV2EndedMessage,
)

@live_session.on("message")
def on_message(message: LiveV2WebSocketMessage) -> None:
    # Handle messages from the API
    pass

@live_session.on("error")
def on_error(error: Exception) -> None:
    # Handle error message
    print(f"Live session error: {error}")

@live_session.once("started")
def on_started(_response: LiveV2InitResponse):
    # Handle start session
    print("Session started. Listeningâ€¦")

@live_session.once("ended")
def on_ended(_ended: LiveV2EndedMessage):
    # Handle end session
    print("Session ended.")
```

</CodeGroup>

## Send audio chunks

You can now start sending us your audio chunks through the WebSocket:

<CodeGroup>


```typescript JavaScript
liveSession.sendAudio(audioChunk)
```

```python Python
live_session.send_audio(audio_chunk)
```

</CodeGroup>

## Read messages
During the whole session, we will send various messages through the WebSocket, the callback URL or webhooks. You can specify which kind of messages you want to receive in the initial configuration. See [`messages_config`](/api-reference/v2/live/init) for WebSocket messages and [`callback_config`](/api-reference/v2/live/init) for callback messages.

Here's an example of how to read a [`transcript`](/api-reference/v2/live/message/transcript) message received through a WebSocket:

<CodeGroup>

```javascript JavaScript
liveSession.on("message", (message) => {
  if (message.type === 'transcript' && message.data.is_final) {
    console.log(`${message.data.id}: ${message.data.utterance.text}`)
});
```

```python Python
@live_session.on("message")
def on_message(message: LiveV2WebSocketMessage) -> None:
    if getattr(message, "type", None) == "transcript":
        data = getattr(message, "data", None)
        if not data:
            return
        is_final = bool(getattr(data, "is_final", False))
        utterance = getattr(data, "utterance", None)
        text = getattr(utterance, "text", "") if utterance else ""
        if is_final and text:
            print(text.strip())
```
</CodeGroup>

<PartialsTip />

## Stop the recording

Once you're done, send us the `stop_recording` message. We will process remaining audio chunks and start the post-processing phase, in which we put together the final audio file and results with the add-ons you requested.

You'll receive a message at every step of the process in the WebSocket, or in the callback if configured. Once the post-processing is done, the WebSocket is closed with a code 1000.

<CodeGroup>


```javascript JavaScript
liveSession.stopRecording()
```

```python Python
live_session.stop_recording()
```

</CodeGroup>

## Get the final results

If you want to get the complete result, you can call the [`GET /v2/live/:id` endpoint](/api-reference/v2/live/get) with the `id` you received from the initial request.

<CodeGroup>

```javascript JavaScript
  const response = await fetch(`https://api.gladia.io/v2/live/${sessionId}`, {
    method: 'GET',
    headers: {
      'x-gladia-key': '<YOUR_GLADIA_API_KEY>',
    },
  });
  if (!response.ok) {
    // Look at the error message
    // It might be a configuration issue
    console.error(`${response.status}: ${(await response.text()) || response.statusText}`)
    return;
  }

  const result = await response.json();
  console.log(result)
```


```python Python
import os
import requests

session_id = "<SESSION_ID>"
api_key = os.environ.get("GLADIA_API_KEY") or "<YOUR_GLADIA_API_KEY>"

response = requests.get(
    f"https://api.gladia.io/v2/live/{session_id}",
    headers={"x-gladia-key": api_key},
)

if not response.ok:
    print(f"{response.status_code}: {response.text or response.reason}")
else:
    print(response.json())
```


```bash cURL
curl --request GET \
  --url https://api.gladia.io/v2/live/ID_OF_THE_SESSION \
  --header 'x-gladia-key: <YOUR_GLADIA_API_KEY>'
```

</CodeGroup>